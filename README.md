# Learning JQ

This documents I would like to share for everyone who had difficulties to work with json data. Particularly, the JQ tools cover the most demanding situation you will face at working with JSON.

## Starting with JSON Basics

### JSON Fundamentals

#### What JSON is?

- Is a lightweight format for data exchange.
- Syntax:  `key: value` pairs.
- Used in APIs, configurations, automations (relevant for networking and devops)

#### Basic Syntax

 - Structure: Objects `({})` , Arrays `([])`
 - Data Types: Strings, numbers , booleans and null
 - Example (file.json):

```json
{
    "router": "Cisco_ASR1000",
    "interfaces": [
        "GigabitEthernet0/0",
        "GigabitEthernet0/1"
    ],
    "active": true,
    "ipv4_addresses": {
        "GigabitEthernet0/0": "192.168.1.1/24"
    }
}

```

### JSON manipulation with JQ

#### Installation and first steps

- Install `jq` in debian-based machines:
    - `sudo apt install jq`

- If the payload is not pretty printed and is not easy readable, turn it *pretty-print*
    - `jq . file.json`

#### Basic Filters

- Accessing to values:

```bash

jq '.router' file.json # "Cisco_ASR1000"
jq '.inerfaces[
    0
]' file.json # "GigabitEthernet0/0"

```

- Filtering objects

```bash

jq '.ipv4_addresses."GigabitEthernet0/0"' file.json

```

#### Operations and Transformations

- Modifying Data

```bash

# Add a new field
jq '. + {
    "DR_SITE": "Century Link"
}' file.json

# Result: {
    "router": "Cisco_ASR1000",
    "interfaces": [
        "GigabitEthernet0/0",
        "GigabitEthernet0/1"
    ],
    "active": true,
    "ipv4_addresses": {
        "GigabitEthernet0/0": "192.168.1.1/24"
    },
    "DR_SITE": "Century Link"
}

```

- Filtering arrays:

```bash

jq '.interfaces | length' file.json # 2

```

#### JQ Advanced Functions

- `map`: Transform array\'s elements

```bash

jq '.interfaces | map(ascii_upcase)' file.json

# Result: [
    "GIGABITETHERNET0/0",
    "GIGABITETHERNET0/1"
]

```

- `select`: Filter by condition

```bash

# Suppose that you have an array of devices:
jq '.devices[] | select(.status == "active")' sensors.json

# Result

{
    "id": 1,
    "name": "Device A",
    "status": "active",
    "type": "sensor"
}
{
    "id": 3,
    "name": "Device C",
    "status": "active",
    "type": "sensor"
}
{
    "id": 5,
    "name": "Device E",
    "status": "active",
    "type": "actuator"
}

```
### Practical Uses that fits Networking tasks

#### Processing Devices Configurations

- Example: Extract all interfaces IPs from a json that is generated by Ansible

```bash

# ip_file.json
{
    "ipv4_addresses": [
        "192.168.1.1",
        "10.0.0.1",
        "172.16.0.5",
        "203.0.113.42"
    ]
}

jq '.ipv4_addresses | map(.) | join(", ")' ip_file.json

# Result: "192.168.1.1, 10.0.0.1, 172.16.0.5, 203.0.113.42"

```

>> You can leverage Integration with APIs by using `curl -s <url> | jq '<key>' | <function(<condition>)>`

#### Reports Creation

- Example: Create a CSV file from a json structure. Will be considered network interfaces and their states

```bash

# devices.json
{
    "interfaces": [
        {
            "name": "eth0",
            "status": "up",
            "ip": "192.168.1.10",
            "mac": "00:1a:2b:3c:4d:5e"
        },
        {
            "name": "wlan0",
            "status": "down",
            "ip": null,
            "mac": "00:1a:2b:3c:4d:5f"
        },
        {
            "name": "lo",
            "status": "up",
            "ip": "127.0.0.1",
            "mac": "00:00:00:00:00:00"
        },
        {
            "name": "eth1",
            "status": "up",
            "ip": "10.0.0.42",
            "mac": "00:1a:2b:3c:4d:60"
        }
    ]
}

# Query for creating Report in CSV format

jq -r '.interfaces[] | [.name, .status, .ip
] | @csv' devices.json

# Result: "eth0",
"up",
"192.168.1.10""wlan0",
"down",
"lo",
"up",
"127.0.0.1""eth1",
"up",
"10.0.0.42"
```

### Advanced JSON topics and best practices

#### JSON in Automation

#### Creating MD using JQ

In the next exercise you will learn how to filter data using JQ and create `on-the-fly` how to write an *md* file.

>> This exercise will show the UP interfaces and create an MARKDOWN file.

- First, we will make a visual inspection of the `devices.json` file and identify which is the `array` name, in our case is *Interfaces[]*
- First, we will use the `select` function for letting know to JQ that we will manipulate data that match its intern condition, as follows
  - `'"# Interfaces Up:\n",(.interfaces[...
])...'` # Print Text and get the value with `()`
  - `'.interfaces[]'` # Return all objects inside the array
  - `'select(.status == "up")'` # Select objects which follow the condition
  - `'"- \(.name) (IP: \(.ip // "none"))"'` # Print the variable value for .name and .ip, if no exist ip value, set default as  "none"

#### Iterating on JSON Arrays with JQ

This is the content of file `routers.json`

```json

{
    "routers": [
        {
            "name": "R1",
            "ip": "192.168.1.1",
            "status": "active"
        },
        {
            "name": "R2",
            "ip": "192.168.1.2",
            "status": "inactive"
        },
        {
            "name": "R3",
            "ip": "192.168.1.3",
            "status": "active"
        }
    ]
}

```

For this purpose you will use together jq and shell loops.

```bash

jq -r '.routers[] | .name' routers.json | while read device_name; do
   echo "Processing data of device: ${device_name}"
done

# Result
Processing data of device: R1
Processing data of device: R2
Processing data of device: R3

```

#### Accessing to multiple fields

For this example will be used the same data of `routers.json` file

```bash

jq -r '.routers[] | "\(.name),\(.ip)"' routers.json | while IFS=, read -r name ip; do
    echo "Device: ${name}, IP: ${ip}"
done

# Result

Device: R1, IP: 192.168.1.1
Device: R2, IP: 192.168.1.2
Device: R3, IP: 192.168.1.3

```

#### Filtering elements before iterating (ex: only `active`)

For this example will be used the same data of `routers.json` file

```bash
jq -r '.routers[] | select(.status == "active") | .name' routers.json | while read device; do
   echo "Actve Device: ${device}"
done

# Result

Actve Device: R1
Actve Device: R3
```

#### Iterating on nested objects (Key-Value pairs)

For this example, will be used the data from `network_config.json` file

```json
# network_config.json

{
  "devices": {
    "switch01": { "ports": 24, "vlan": "10" },
    "switch02": { "ports": 48, "vlan": "20" }
  }
}
```
##### Iterating on key and pairs

Use `to_entries` in order to convert the object into an array {key, value}

```bash
jq -r '.devices| to_entries[] | "\(.key),\(.value.ports),\(.value.vlan)"' network_config.json | while IFS=, read -r switch ports vlan; do
   echo "Switch: ${switch}, Port: ${ports}, VLAN: ${vlan}"
done

# Result

Switch: switch01, Port: 24, VLAN: 10
Switch: switch02, Port: 48, VLAN: 20
```

#### Nested Arrays

For this example will be used the `interfaces.json` file

```json
{
  "devices": [
    {
      "name": "Router_A",
      "interfaces": [
        { "name": "GigabitEthernet0/0", "ip": "10.0.0.1" },
        { "name": "GigabitEthernet0/1", "ip": "10.0.0.2" }
      ]
    },
    {
      "name": "Router_B",
      "interfaces": [
        { "name": "GigabitEthernet0/0", "ip": "10.0.1.1" }
      ]
    }
  ]
}
```
##### Iterating on devices and interfaces

```bash
jq -c '.devices[]' interfaces.json | while read -r device; do
   device_name=$(jq -r '.name' <<< "$device")
   echo "Device: ${device_name}"
   jq -r '.interfaces[] | "- \(.name): \(.ip)"' <<< "$device"
done

# Result

Device: Router_A
- GigabitEthernet0/0: 10.0.0.1
- GigabitEthernet0/1: 10.0.0.2
Device: Router_B
- GigabitEthernet0/0: 10.0.1.1
```
