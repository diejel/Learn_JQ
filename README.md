
# Learning JQ

- [1. Learning JQ](#1-learning-jq)
    - [1.0.1. Starting with JSON Basics](#101-starting-with-json-basics)
      - [1.0.1.1. JSON Fundamentals](#1011-json-fundamentals)
        - [1.0.1.1.1. What JSON is?](#10111-what-json-is)
        - [1.0.1.1.2. Basic Syntax](#10112-basic-syntax)
    - [1.0.2. JSON manipulation with JQ](#102-json-manipulation-with-jq)
      - [1.0.2.1. Installation and first steps](#1021-installation-and-first-steps)
      - [1.0.2.2. Basic Filters](#1022-basic-filters)
    - [1.0.3. Operations and Transformations](#103-operations-and-transformations)
    - [1.0.4. JQ Advanced Functions](#104-jq-advanced-functions)
    - [1.0.5. Practical Uses that fits Networking tasks](#105-practical-uses-that-fits-networking-tasks)
      - [1.0.5.1. Processing Devices Configurations](#1051-processing-devices-configurations)
      - [1.0.5.2. Reports Creation](#1052-reports-creation)
    - [1.0.6. Advanced JSON topics and best practices](#106-advanced-json-topics-and-best-practices)
      - [1.0.6.1. JSON in Automation](#1061-json-in-automation)
      - [1.0.6.2. Creating MD using JQ](#1062-creating-md-using-jq)
    - [1.0.7. Iterating on JSON Arrays with JQ](#107-iterating-on-json-arrays-with-jq)
      - [1.0.7.1. Accessing to multiple fields](#1071-accessing-to-multiple-fields)
      - [1.0.7.2. Filtering elements before iterating (ex: only `active`)](#1072-filtering-elements-before-iterating-ex-only-active)
    - [1.0.8. Iterating on nested objects (Key-Value pairs)](#108-iterating-on-nested-objects-key-value-pairs)
      - [1.0.8.1. Iterating on key and pairs](#1081-iterating-on-key-and-pairs)
    - [1.0.9. Nested Arrays](#109-nested-arrays)
      - [1.0.9.1. Iterating on devices and interfaces](#1091-iterating-on-devices-and-interfaces)
    - [Generate commands or configurations](#generate-commands-or-configurations)

This documents I would like to share for everyone who had difficulties to work with json data. Particularly, the JQ tools cover the most demanding situation you will face at working with JSON.

### 1.0.1. Starting with JSON Basics

#### 1.0.1.1. JSON Fundamentals

##### 1.0.1.1.1. What JSON is?

- Is a lightweight format for data exchange.
- Syntax:  `key: value` pairs.
- Used in APIs, configurations, automations (relevant for networking and devops)

##### 1.0.1.1.2. Basic Syntax

 - Structure: Objects `({})` , Arrays `([])`
 - Data Types: Strings, numbers , booleans and null
 - Example (file.json):

```json
{
    "router": "Cisco_ASR1000",
    "interfaces": [
        "GigabitEthernet0/0",
        "GigabitEthernet0/1"
    ],
    "active": true,
    "ipv4_addresses": {
        "GigabitEthernet0/0": "192.168.1.1/24"
    }
}

```

### 1.0.2. JSON manipulation with JQ

#### 1.0.2.1. Installation and first steps

- Install `jq` in debian-based machines:
    - `sudo apt install jq`

- If the payload is not pretty printed and is not easy readable, turn it *pretty-print*
    - `jq . file.json`

#### 1.0.2.2. Basic Filters

- Accessing to values:

```bash

jq '.router' file.json # "Cisco_ASR1000"
jq '.inerfaces[
    0
]' file.json # "GigabitEthernet0/0"

```

- Filtering objects

```bash

jq '.ipv4_addresses."GigabitEthernet0/0"' file.json

```

###  1.0.3. Operations and Transformations

- Modifying Data

```bash

# Add a new field
jq '. + {
    "DR_SITE": "Century Link"
}' file.json

# Result: {
    "router": "Cisco_ASR1000",
    "interfaces": [
        "GigabitEthernet0/0",
        "GigabitEthernet0/1"
    ],
    "active": true,
    "ipv4_addresses": {
        "GigabitEthernet0/0": "192.168.1.1/24"
    },
    "DR_SITE": "Century Link"
}

```

- Filtering arrays:

```bash

jq '.interfaces | length' file.json # 2

```

### 1.0.4. JQ Advanced Functions

- `map`: Transform array\'s elements

```bash

jq '.interfaces | map(ascii_upcase)' file.json

# Result: [
    "GIGABITETHERNET0/0",
    "GIGABITETHERNET0/1"
]

```

- `select`: Filter by condition

```bash

# Suppose that you have an array of devices:
jq '.devices[] | select(.status == "active")' sensors.json

# Result

{
    "id": 1,
    "name": "Device A",
    "status": "active",
    "type": "sensor"
}
{
    "id": 3,
    "name": "Device C",
    "status": "active",
    "type": "sensor"
}
{
    "id": 5,
    "name": "Device E",
    "status": "active",
    "type": "actuator"
}

```
### 1.0.5. Practical Uses that fits Networking tasks

####  1.0.5.1. Processing Devices Configurations

- Example: Extract all interfaces IPs from a json that is generated by Ansible

```bash

# ip_file.json
{
    "ipv4_addresses": [
        "192.168.1.1",
        "10.0.0.1",
        "172.16.0.5",
        "203.0.113.42"
    ]
}

jq '.ipv4_addresses | map(.) | join(", ")' ip_file.json

# Result: "192.168.1.1, 10.0.0.1, 172.16.0.5, 203.0.113.42"

```

>> You can leverage Integration with APIs by using `curl -s <url> | jq '<key>' | <function(<condition>)>`

####  1.0.5.2. Reports Creation

- Example: Create a CSV file from a json structure. Will be considered network interfaces and their states

```bash

# devices.json
{
    "interfaces": [
        {
            "name": "eth0",
            "status": "up",
            "ip": "192.168.1.10",
            "mac": "00:1a:2b:3c:4d:5e"
        },
        {
            "name": "wlan0",
            "status": "down",
            "ip": null,
            "mac": "00:1a:2b:3c:4d:5f"
        },
        {
            "name": "lo",
            "status": "up",
            "ip": "127.0.0.1",
            "mac": "00:00:00:00:00:00"
        },
        {
            "name": "eth1",
            "status": "up",
            "ip": "10.0.0.42",
            "mac": "00:1a:2b:3c:4d:60"
        }
    ]
}

# Query for creating Report in CSV format

jq -r '.interfaces[] | [.name, .status, .ip
] | @csv' devices.json

# Result: "eth0",
"eth0","up","192.168.1.10"
"wlan0","down",
"lo","up","127.0.0.1"
"eth1","up","10.0.0.42"
```

###  1.0.6. Advanced JSON topics and best practices

#### 1.0.6.1. JSON in Automation

#### 1.0.6.2. Creating MD using JQ

In the next exercise you will learn how to filter data using JQ and create `on-the-fly` how to write an *md* file.

>> This exercise will show the UP interfaces and create an MARKDOWN file.

- First, we will make a visual inspection of the `devices.json` file and identify which is the `array` name, in our case is *Interfaces[]*
- First, we will use the `select` function for letting know to JQ that we will manipulate data that match its intern condition, as follows
  - `'"# Interfaces Up:\n",(.interfaces[...
])...'` # Print Text and get the value with `()`
  - `'.interfaces[]'` # Return all objects inside the array
  - `'select(.status == "up")'` # Select objects which follow the condition
  - `'"- \(.name) (IP: \(.ip // "none"))"'` # Print the variable value for .name and .ip, if no exist ip value, set default as  "none"

### 1.0.7. Iterating on JSON Arrays with JQ

This is the content of file `routers.json`

```json

{
    "routers": [
        {
            "name": "R1",
            "ip": "192.168.1.1",
            "status": "active"
        },
        {
            "name": "R2",
            "ip": "192.168.1.2",
            "status": "inactive"
        },
        {
            "name": "R3",
            "ip": "192.168.1.3",
            "status": "active"
        }
    ]
}

```

For this purpose you will use together jq and shell loops.

```bash

jq -r '.routers[] | .name' routers.json | while read device_name; do
   echo "Processing data of device: ${device_name}"
done

# Result
Processing data of device: R1
Processing data of device: R2
Processing data of device: R3

```

#### 1.0.7.1. Accessing to multiple fields

For this example will be used the same data of `routers.json` file

```bash

jq -r '.routers[] | "\(.name),\(.ip)"' routers.json | while IFS=, read -r name ip; do
    echo "Device: ${name}, IP: ${ip}"
done

# Result

Device: R1, IP: 192.168.1.1
Device: R2, IP: 192.168.1.2
Device: R3, IP: 192.168.1.3

```

#### 1.0.7.2. Filtering elements before iterating (ex: only `active`)

For this example will be used the same data of `routers.json` file

```bash
jq -r '.routers[] | select(.status == "active") | .name' routers.json | while read device; do
   echo "Actve Device: ${device}"
done

# Result

Actve Device: R1
Actve Device: R3
```

###  1.0.8. Iterating on nested objects (Key-Value pairs)

For this example, will be used the data from `network_config.json` file

```json
# network_config.json

{
  "devices": {
    "switch01": { "ports": 24, "vlan": "10" },
    "switch02": { "ports": 48, "vlan": "20" }
  }
}
```
#### 1.0.8.1. Iterating on key and pairs

Use `to_entries` in order to convert the object into an array {key, value}

```bash
jq -r '.devices| to_entries[] | "\(.key),\(.value.ports),\(.value.vlan)"' network_config.json | while IFS=, read -r switch ports vlan; do
   echo "Switch: ${switch}, Port: ${ports}, VLAN: ${vlan}"
done

# Result

Switch: switch01, Port: 24, VLAN: 10
Switch: switch02, Port: 48, VLAN: 20
```

### 1.0.9. Nested Arrays

For this example will be used the `interfaces.json` file

```json
{
  "devices": [
    {
      "name": "Router_A",
      "interfaces": [
        { "name": "GigabitEthernet0/0", "ip": "10.0.0.1" },
        { "name": "GigabitEthernet0/1", "ip": "10.0.0.2" }
      ]
    },
    {
      "name": "Router_B",
      "interfaces": [
        { "name": "GigabitEthernet0/0", "ip": "10.0.1.1" }
      ]
    }
  ]
}
```
#### 1.0.9.1. Iterating on devices and interfaces

```bash
jq -c '.devices[]' interfaces.json | while read -r device; do
   device_name=$(jq -r '.name' <<< "$device")
   echo "Device: ${device_name}"
   jq -r '.interfaces[] | "- \(.name): \(.ip)"' <<< "$device"
done

# Result

Device: Router_A
- GigabitEthernet0/0: 10.0.0.1
- GigabitEthernet0/1: 10.0.0.2
Device: Router_B
- GigabitEthernet0/0: 10.0.1.1
```

### 1.0.10. Generate commands or configurations

THis is useful fro creating commands forenabling interfaces based on json data

```json 
# interfaces_status.json
[
  { "interface": "GigabitEthernet0/0", "action": "up" },
  { "interface": "GigabitEthernet0/1", "action": "down" }
]
```

Will be created the cisco command: `interface <iface_name> <shutdown|no_shutdown>`

```bash
jq -r '.[] | "interface \(.interface)\n \(if .action != "down" then "no shutdown" else "shutdown" end)"' interfaces_status.json

#Result:
interface GigabitEthernet0/0
  no shutdown 
interface GigabitEthernet0/1
  shutdown

```
